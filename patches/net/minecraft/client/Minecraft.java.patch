--- a/net/minecraft/client/Minecraft.java
+++ b/net/minecraft/client/Minecraft.java
@@ -1,51 +1,123 @@
 package net.minecraft.client;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
-import com.google.common.hash.Hashing;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.ListenableFutureTask;
-import com.mojang.authlib.AuthenticationService;
-import com.mojang.authlib.GameProfile;
-import com.mojang.authlib.GameProfileRepository;
-import com.mojang.authlib.minecraft.MinecraftSessionService;
-import com.mojang.authlib.properties.PropertyMap;
-import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.MalformedURLException;
 import java.net.Proxy;
 import java.net.SocketAddress;
+import java.net.URL;
+import java.net.URLClassLoader;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
 import java.text.DecimalFormat;
 import java.text.SimpleDateFormat;
+import java.util.ArrayDeque;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.Deque;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Queue;
+import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
-import java.util.function.Consumer;
-import java.util.function.Function;
-import java.util.function.Predicate;
 import java.util.stream.Collectors;
+
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+
+import org.apache.commons.io.Charsets;
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.LWJGLException;
+import org.lwjgl.LWJGLUtil;
+import org.lwjgl.Sys;
+import org.lwjgl.input.Cursor;
+import org.lwjgl.input.Keyboard;
+import org.lwjgl.input.Mouse;
+import org.lwjgl.opengl.ARBShaderObjects;
+import org.lwjgl.opengl.ContextCapabilities;
+import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.DisplayMode;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL13;
+import org.lwjgl.opengl.GLContext;
+import org.lwjgl.opengl.OpenGLException;
+import org.lwjgl.opengl.PixelFormat;
+import org.lwjgl.util.glu.GLU;
+import org.lwjgl.util.vector.Matrix4f;
+import org.vivecraft.api.ErrorHelper;
+import org.vivecraft.control.VRButtonMapping;
+import org.vivecraft.gameplay.OpenVRPlayer;
+import org.vivecraft.gameplay.screenhandlers.GuiHandler;
+import org.vivecraft.gameplay.screenhandlers.KeyboardHandler;
+import org.vivecraft.gameplay.screenhandlers.RadialHandler;
+import org.vivecraft.gameplay.trackers.BackpackTracker;
+import org.vivecraft.gameplay.trackers.BowTracker;
+import org.vivecraft.gameplay.trackers.ClimbTracker;
+import org.vivecraft.gameplay.trackers.EatingTracker;
+import org.vivecraft.gameplay.trackers.HorseTracker;
+import org.vivecraft.gameplay.trackers.JumpTracker;
+import org.vivecraft.gameplay.trackers.RowTracker;
+import org.vivecraft.gameplay.trackers.RunTracker;
+import org.vivecraft.gameplay.trackers.SneakTracker;
+import org.vivecraft.gameplay.trackers.SwimTracker;
+import org.vivecraft.gameplay.trackers.SwingTracker;
+import org.vivecraft.gameplay.trackers.TeleportTracker;
+import org.vivecraft.gameplay.trackers.VehicleTracker;
+import org.vivecraft.gui.GuiRadial;
+import org.vivecraft.provider.MCOpenVR;
+import org.vivecraft.provider.OpenVRStereoRenderer;
+import org.vivecraft.render.MenuWorldRenderer;
+import org.vivecraft.render.PlayerModelController;
+import org.vivecraft.render.RenderConfigException;
+import org.vivecraft.render.RenderPass;
+import org.vivecraft.render.VRShaders;
+import org.vivecraft.settings.VRHotkeys;
+import org.vivecraft.settings.VRSettings;
+import org.vivecraft.settings.VRSettings.VrOptions;
+import org.vivecraft.utils.MCReflection;
+import org.vivecraft.utils.MenuWorldDownloader;
+import org.vivecraft.utils.MenuWorldExporter;
+import org.vivecraft.utils.Utils;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+import com.google.common.hash.Hashing;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import com.mojang.authlib.AuthenticationService;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.authlib.properties.PropertyMap;
+import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+
+import de.fruitfly.ovr.structs.GLConfig;
 import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.audio.MusicTicker;
 import net.minecraft.client.audio.SoundHandler;
+import net.minecraft.client.audio.SoundManager;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.gui.GuiChat;
@@ -80,6 +152,7 @@
 import net.minecraft.client.renderer.BlockRendererDispatcher;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.EntityRenderer;
+import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.ItemRenderer;
 import net.minecraft.client.renderer.OpenGlHelper;
@@ -163,6 +236,7 @@
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.integrated.IntegratedServer;
 import net.minecraft.server.management.PlayerProfileCache;
+import net.minecraft.src.Config;
 import net.minecraft.stats.RecipeBook;
 import net.minecraft.stats.StatisticsManager;
 import net.minecraft.tileentity.TileEntity;
@@ -187,12 +261,14 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.Vec3d;
 import net.minecraft.util.text.ITextComponent;
 import net.minecraft.util.text.Style;
 import net.minecraft.util.text.TextComponentKeybind;
 import net.minecraft.util.text.TextComponentString;
 import net.minecraft.util.text.TextComponentTranslation;
 import net.minecraft.util.text.TextFormatting;
+import net.minecraft.world.DimensionType;
 import net.minecraft.world.EnumDifficulty;
 import net.minecraft.world.WorldProviderEnd;
 import net.minecraft.world.WorldProviderHell;
@@ -201,25 +277,90 @@
 import net.minecraft.world.storage.ISaveFormat;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.WorldInfo;
-import org.apache.commons.io.Charsets;
-import org.apache.commons.io.IOUtils;
-import org.apache.commons.lang3.Validate;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-import org.lwjgl.LWJGLException;
-import org.lwjgl.Sys;
-import org.lwjgl.input.Keyboard;
-import org.lwjgl.input.Mouse;
-import org.lwjgl.opengl.ContextCapabilities;
-import org.lwjgl.opengl.Display;
-import org.lwjgl.opengl.DisplayMode;
-import org.lwjgl.opengl.GLContext;
-import org.lwjgl.opengl.OpenGLException;
-import org.lwjgl.opengl.PixelFormat;
-import org.lwjgl.util.glu.GLU;
+import net.optifine.gui.GuiScreenOF;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.Shaders;
+import paulscode.sound.SoundSystem;
 
 public class Minecraft implements IThreadListener, ISnooperInfo
 {
+	// VIVE START - teleport movement
+	public OpenVRPlayer vrPlayer; 
+	public BackpackTracker backpackTracker = new BackpackTracker(this);
+	public BowTracker bowTracker = new BowTracker(this);
+	public SwimTracker swimTracker = new SwimTracker(this);
+	public EatingTracker autoFood=new EatingTracker(this);
+	public JumpTracker jumpTracker=new JumpTracker(this);
+	public SneakTracker sneakTracker=new SneakTracker(this);
+	public ClimbTracker climbTracker = new ClimbTracker(this);
+	public RunTracker runTracker  = new RunTracker(this);
+	public RowTracker rowTracker  = new RowTracker(this);
+	public TeleportTracker teleportTracker = new TeleportTracker(this);
+	public SwingTracker swingTracker = new SwingTracker(this);
+	public HorseTracker horseTracker = new HorseTracker(this);
+	public VehicleTracker vehicleTracker = new VehicleTracker(this);
+	// VIVE END - teleport movement
+	
+	/** MINECRIFT */
+	
+	public boolean minecriftDebug = false;
+	public final float PIOVER180 = (float)(Math.PI/180);
+	
+	public int lastShaderIndex = -1;
+	public Object displayImpl = null;
+	public Field fieldHwnd = null;
+	public Field fieldDisplay = null;
+	public Field fieldWindow = null;
+	public Field fieldResized = null;
+	public Method fieldResizedMethod = null;
+	public OpenVRStereoRenderer stereoProvider;
+	public VRSettings vrSettings;
+	public long lastIntegratedServerLaunchCheck = 0;
+	public boolean integratedServerLaunchInProgress = false;
+	public boolean lastEnableVsync = true;
+	public int grabScreenShot = 0;
+	public Cursor nativeMouseCursor = null;
+	public boolean lastShowMouseNative = true;
+	public Cursor invisibleMouseCursor = null;
+	public GLConfig glConfig = new GLConfig();
+	public long lastWindow = 0;
+	public int lastRenderDistanceChunks = -1;
+	public boolean lastFogFancy = true;
+	public boolean lastFogFast = false;
+	public float lastWorldScale = 0f;
+	public boolean enableWorldExport = false;
+	public DimensionType lastDimensionId = DimensionType.OVERWORLD;
+	public SoundManager sndManager = null;
+	public MenuWorldRenderer menuWorldRenderer;
+
+	
+	private FloatBuffer matrixBuffer = GLAllocation.createDirectFloatBuffer(16);
+	private FloatBuffer matrixBuffer2 = GLAllocation.createDirectFloatBuffer(16);
+
+	private boolean firstInit = true;
+	public boolean showSplashScreen = true;
+	public long splashTimer1 = 0;
+	public long splashTimer2 = 0;
+	private Framebuffer splash;
+	private float splashFadeAlpha = 0;
+	private int lastGuiScale = -1;
+	public Deque<Long> runTickTimeNanos = new ArrayDeque<Long>();
+	public long medianRunTickTimeNanos = 0;
+	public long frameIndex = 0;
+	public boolean visible = true;
+	public ErrorHelper errorHelper;
+	public static final String RENDER_SETUP_FAILURE_MESSAGE = "Failed to initialise stereo rendering plugin: ";
+	public static final int ERROR_DISPLAY_TIME_SECS = 10;
+	
+
+	/*
+	 * The minecriftVerString will be automatically updated by the build scripts, do not modify here.
+	 * Modify minecriftversion.py in root minecrift dir.
+	 */
+    public final String minecriftVerString = "Vivecraft 1.12.2 jrbudda-8-b12";
+	/* end version */
+	/** END MINECRIFT */
+    
     private static final Logger LOGGER = LogManager.getLogger();
     private static final ResourceLocation LOCATION_MOJANG_PNG = new ResourceLocation("textures/gui/title/mojang.png");
     public static final boolean IS_RUNNING_ON_MAC = Util.getOSType() == Util.EnumOS.OSX;
@@ -240,7 +381,7 @@
     private ServerData currentServerData;
 
     /** The RenderEngine instance used by Minecraft */
-    private TextureManager renderEngine;
+    public TextureManager renderEngine; //VIVECRAFT MAKE PUBLIC
 
     /** The instance of the Minecraft Client, set in the constructor. */
     private static Minecraft instance;
@@ -257,7 +398,7 @@
 
     /** True if the player is connected to a realms server */
     private boolean connectedToRealms;
-    private final Timer timer = new Timer(20.0F);
+    public final Timer timer = new Timer(20f);
 
     /** Instance of PlayerUsageSnooper. */
     private final Snooper usageSnooper = new Snooper("client", this, MinecraftServer.getCurrentTimeMillis());
@@ -357,7 +498,7 @@
     private final boolean jvm64bit;
     private final boolean isDemo;
     @Nullable
-    private NetworkManager myNetworkManager;
+    public NetworkManager myNetworkManager;
     private boolean integratedServerIsRunning;
 
     /** The profiler instance */
@@ -369,15 +510,16 @@
     private long debugCrashKeyPressTime = -1L;
     private IReloadableResourceManager mcResourceManager;
     private final MetadataSerializer metadataSerializer_ = new MetadataSerializer();
-    private final List<IResourcePack> defaultResourcePacks = Lists.<IResourcePack>newArrayList();
-    private final DefaultResourcePack mcDefaultResourcePack;
+    //Forge make public
+    public final List<IResourcePack> defaultResourcePacks = Lists.<IResourcePack>newArrayList();
+    public final DefaultResourcePack mcDefaultResourcePack;
     private ResourcePackRepository mcResourcePackRepository;
     private LanguageManager mcLanguageManager;
     private BlockColors blockColors;
     private ItemColors itemColors;
-    private Framebuffer framebufferMc;
+    public Framebuffer framebufferMc;
     private TextureMap textureMapBlocks;
-    private SoundHandler mcSoundHandler;
+	private  SoundHandler mcSoundHandler; 
     private MusicTicker mcMusicTicker;
     private ResourceLocation mojangLogo;
     private final MinecraftSessionService sessionService;
@@ -390,7 +532,7 @@
      * The BlockRenderDispatcher instance that will be used based off gamesettings
      */
     private BlockRendererDispatcher blockRenderDispatcher;
-    private final GuiToast toastGui;
+    public final GuiToast toastGui;
 
     /**
      * Set to true to keep the game loop running. Set to false by shutdown() to allow the game loop to exit cleanly.
@@ -412,10 +554,23 @@
 
     /** Profiler currently displayed in the debug screen pie chart */
     private String debugProfilerName = "root";
-
-    public Minecraft(GameConfiguration gameConfig)
+	private float frameDelta;
+	
+	public RenderPass currentPass;
+	private boolean lastClick;
+
+	public int hmdAvgLength = 90;
+	public LinkedList<Vec3d> hmdPosSamples = new LinkedList<Vec3d>();
+	public LinkedList<Float> hmdYawSamples = new LinkedList<Float>();
+	private float hmdYawTotal;
+	private float hmdYawLast;
+	public int tickCounter;
+	private boolean trigger;
+	
+	public Minecraft(GameConfiguration gameConfig)
     {
         instance = this;
+        loadClassPath();
         this.mcDataDir = gameConfig.folderInfo.mcDataDir;
         this.fileAssets = gameConfig.folderInfo.assetsDir;
         this.fileResourcepacks = gameConfig.folderInfo.resourcePacksDir;
@@ -428,12 +583,14 @@
         this.sessionService = (new YggdrasilAuthenticationService(this.proxy, UUID.randomUUID().toString())).createMinecraftSessionService();
         this.session = gameConfig.userInfo.session;
         LOGGER.info("Setting user: {}", (Object)this.session.getUsername());
-        LOGGER.debug("(Session ID is {})", (Object)this.session.getSessionID());
+        //LOGGER.debug("(Session ID is {})", (Object)this.session.getSessionID());
         this.isDemo = gameConfig.gameInfo.isDemo;
-        this.displayWidth = gameConfig.displayInfo.width > 0 ? gameConfig.displayInfo.width : 1;
-        this.displayHeight = gameConfig.displayInfo.height > 0 ? gameConfig.displayInfo.height : 1;
-        this.tempDisplayWidth = gameConfig.displayInfo.width;
-        this.tempDisplayHeight = gameConfig.displayInfo.height;
+		/** MINECRIFT **/
+		displayWidth = 1280;
+		displayHeight = 720;
+        this.tempDisplayWidth = 1280;
+        this.tempDisplayHeight = 720;
+		/** END MINECRIFT **/
         this.fullscreen = gameConfig.displayInfo.fullscreen;
         this.jvm64bit = isJvm64bit();
         this.integratedServer = null;
@@ -451,6 +608,15 @@
         this.dataFixer = DataFixesManager.createFixer();
         this.toastGui = new GuiToast(this);
         this.tutorial = new Tutorial(this);
+        
+		/** MINECRIFT **/
+		VRSettings.initSettings(this, this.mcDataDir);
+		if (!vrSettings.badStereoProviderPluginID.isEmpty()) {
+			vrSettings.stereoProviderPluginID = vrSettings.badStereoProviderPluginID;
+			vrSettings.badStereoProviderPluginID = "";
+			vrSettings.saveOptions();
+		}
+		/** END MINECRIFT **/
     }
 
     public void run()
@@ -528,6 +694,7 @@
      */
     private void init() throws LWJGLException, IOException
     {
+    		
         this.gameSettings = new GameSettings(this, this.mcDataDir);
         this.creativeSettings = new CreativeSettings(this, this.mcDataDir);
         this.defaultResourcePacks.add(this.mcDefaultResourcePack);
@@ -543,6 +710,8 @@
         this.setWindowIcon();
         this.setInitialDisplayMode();
         this.createDisplay();
+        Display.setTitle(this.minecriftVerString + " VR");
+        LOGGER.info("MC Version: {}", this.minecriftVerString);
         OpenGlHelper.initializeTextures();
         this.framebufferMc = new Framebuffer(this.displayWidth, this.displayHeight, true);
         this.framebufferMc.setFramebufferColor(0.0F, 0.0F, 0.0F, 0.0F);
@@ -551,10 +720,31 @@
         this.mcResourceManager = new SimpleReloadableResourceManager(this.metadataSerializer_);
         this.mcLanguageManager = new LanguageManager(this.metadataSerializer_, this.gameSettings.language);
         this.mcResourceManager.registerReloadListener(this.mcLanguageManager);
-        this.refreshResources();
+        //Forge
+        Object fmlClientHandler = null;
+		if( Reflector.FMLClientHandler_instance.exists())
+		{
+			fmlClientHandler = Reflector.call( Reflector.FMLClientHandler_instance);
+		}
+		if( fmlClientHandler != null)
+		{
+			Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_beginMinecraftLoading, new Object[] {this, this.defaultResourcePacks,this.mcResourceManager, this.metadataSerializer_});
+		}
+		else {
+			this.refreshResources();
+		}
+		//
         this.renderEngine = new TextureManager(this.mcResourceManager);
         this.mcResourceManager.registerReloadListener(this.renderEngine);
-        this.drawSplashScreen(this.renderEngine);
+		//Forge
+        boolean hasForge = Reflector.forgeExists();
+		if (hasForge) {
+			Reflector.callVoid(Reflector.SplashProgress_drawVanillaScreen, this.renderEngine);
+		}
+		else {
+			this.drawSplashScreen(this.renderEngine);
+		}
+		//
         this.skinManager = new SkinManager(this.renderEngine, new File(this.fileAssets, "skins"), this.sessionService);
         this.saveLoader = new AnvilSaveConverter(new File(this.mcDataDir, "saves"), this.dataFixer);
         this.mcSoundHandler = new SoundHandler(this.mcResourceManager, this.gameSettings);
@@ -567,12 +757,29 @@
             this.fontRenderer.setUnicodeFlag(this.isUnicode());
             this.fontRenderer.setBidiFlag(this.mcLanguageManager.isCurrentLanguageBidirectional());
         }
-
+        
+		/** MINECRIFT */
+		try {
+			System.out.println("Initialzing Vivecraft");
+			initMinecrift();	
+			System.out.println("Vivecraft Initialized");
+		} catch (Exception e) {
+			// TODO Auto-generated catch block
+			System.out.println("Error Initializing Vivecraft " + e.getMessage());
+			e.printStackTrace();
+		}
+		/** END MINECRIFT */
+        
         this.standardGalacticFontRenderer = new FontRenderer(this.gameSettings, new ResourceLocation("textures/font/ascii_sga.png"), this.renderEngine, false);
         this.mcResourceManager.registerReloadListener(this.fontRenderer);
         this.mcResourceManager.registerReloadListener(this.standardGalacticFontRenderer);
         this.mcResourceManager.registerReloadListener(new GrassColorReloadListener());
         this.mcResourceManager.registerReloadListener(new FoliageColorReloadListener());
+		Object bar = null;
+		if (hasForge) {
+			bar = Reflector.call(Reflector.FMLCommonProgressManager_push, "Rendering Setup", 5, true);
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, "Loading Render Manager");
+		}
         this.mouseHelper = new MouseHelper();
         this.checkGLError("Pre startup");
         GlStateManager.enableTexture2D();
@@ -587,19 +794,26 @@
         GlStateManager.loadIdentity();
         GlStateManager.matrixMode(5888);
         this.checkGLError("Startup");
-        this.textureMapBlocks = new TextureMap("textures");
+		if (hasForge) Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, "Loading Texture Map");
+        this.textureMapBlocks = new TextureMap("textures", true);
         this.textureMapBlocks.setMipmapLevels(this.gameSettings.mipmapLevels);
         this.renderEngine.loadTickableTexture(TextureMap.LOCATION_BLOCKS_TEXTURE, this.textureMapBlocks);
         this.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
         this.textureMapBlocks.setBlurMipmapDirect(false, this.gameSettings.mipmapLevels > 0);
+		if (hasForge) Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, "Loading Model Manager");
         this.modelManager = new ModelManager(this.textureMapBlocks);
         this.mcResourceManager.registerReloadListener(this.modelManager);
         this.blockColors = BlockColors.init();
         this.itemColors = ItemColors.init(this.blockColors);
         this.renderItem = new RenderItem(this.renderEngine, this.modelManager, this.itemColors);
         this.renderManager = new RenderManager(this.renderEngine, this.renderItem);
+		if (hasForge) Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, "Loading Item Renderer");
         this.itemRenderer = new ItemRenderer(this);
         this.mcResourceManager.registerReloadListener(this.renderItem);
+		if (hasForge){
+			Reflector.callVoid(bar, Reflector.FMLCommonProgressManager_ProgressBar_step, "Loading Item Renderer");
+			Reflector.callVoid(Reflector.SplashProgress_pause);
+		}
         this.entityRenderer = new EntityRenderer(this, this.mcResourceManager);
         this.mcResourceManager.registerReloadListener(this.entityRenderer);
         this.blockRenderDispatcher = new BlockRendererDispatcher(this.modelManager.getBlockModelShapes(), this.blockColors);
@@ -610,23 +824,92 @@
         this.mcResourceManager.registerReloadListener(this.searchTreeManager);
         GlStateManager.viewport(0, 0, this.displayWidth, this.displayHeight);
         this.effectRenderer = new ParticleManager(this.world, this.renderEngine);
+        
+        //Forge
+        if (hasForge){
+        	Reflector.callVoid(Reflector.SplashProgress_resume);
+        	Reflector.call(Reflector.FMLCommonProgressManager_pop, bar);
+        	Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_finishMinecraftLoading);
+        } else {
+        	this.refreshResources();
+        }
+    
         this.checkGLError("Post startup");
-        this.ingameGUI = new GuiIngame(this);
+        
+		if(hasForge)
+		{
+			this.ingameGUI = (GuiIngame)Reflector.newInstance(Reflector.ForgeGuiIngame_Constructor, this);
+		}
+		else
+		{
+			this.ingameGUI = new GuiIngame(this);
+		}
+	    //
+		
+        // VIVE: Main menu world initialization
+		try {
+			InputStream inputStream = MenuWorldDownloader.getRandomWorld();
+			if (inputStream != null) {
+				LOGGER.info("Initializing main menu world renderer...");
+		        this.menuWorldRenderer = new MenuWorldRenderer();
+				this.menuWorldRenderer.init();
+				LOGGER.info("Loading world data...");
+				this.menuWorldRenderer.setWorld(MenuWorldExporter.loadWorld(inputStream));
+				LOGGER.info("Building geometry...");
+				this.menuWorldRenderer.prepare();
+				this.entityRenderer.menuWorldFastTime = new Random().nextInt(10) == 0;
+			} else {
+				LOGGER.error("Failed to load any main menu world, falling back to old menu room");
+			}
+		} catch (Exception e) {
+			LOGGER.error("Exception thrown when loading main menu world, falling back to old menu room");
+			e.printStackTrace();
+			if (this.menuWorldRenderer != null) {
+				this.menuWorldRenderer.destroy();
+				this.menuWorldRenderer.setWorld(null);
+			}
+		} catch (OutOfMemoryError e) { // Only effective way of preventing crash on poop computers with low heap size
+			LOGGER.error("OutOfMemoryError while loading main menu world. Low heap size or 32-bit Java?");
+			if (this.menuWorldRenderer != null) {
+				this.menuWorldRenderer.destroy();
+				this.menuWorldRenderer.setWorld(null);
+			}
+		}
 
         if (this.serverName != null)
         {
-            this.displayGuiScreen(new GuiConnecting(new GuiMainMenu(), this, this.serverName, this.serverPort));
+        	//Forge
+			if( fmlClientHandler != null ) {
+				Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_connectToServerAtStartup, new Object[]{this.serverName, this.serverPort});
+			}
+			else {
+				this.displayGuiScreen(new GuiConnecting(new GuiMainMenu(), this, this.serverName, this.serverPort));
+			}
+			//
         }
         else
         {
             this.displayGuiScreen(new GuiMainMenu());
         }
 
-        this.renderEngine.deleteTexture(this.mojangLogo);
+        //Forge
+		if (hasForge) {
+			Reflector.callVoid(Reflector.SplashProgress_clearVanillaResources, new Object[] {renderEngine, mojangLogo});
+		}
+		else {
+			this.renderEngine.deleteTexture(this.mojangLogo);
+		}      
+		//	
+		
         this.mojangLogo = null;
         this.loadingScreen = new LoadingScreenRenderer(this);
         this.debugRenderer = new DebugRenderer(this);
-
+        this.gameSettings.enableVsync = false;
+        
+		if( hasForge ) {
+			Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_onInitializationComplete);
+		}
+        
         if (this.gameSettings.fullScreen && !this.fullscreen)
         {
             this.toggleFullscreen();
@@ -634,15 +917,20 @@
 
         try
         {
-            Display.setVSyncEnabled(this.gameSettings.enableVsync);
+            Display.setVSyncEnabled(false);
         }
         catch (OpenGLException var2)
         {
             this.gameSettings.enableVsync = false;
             this.gameSettings.saveOptions();
         }
-
-        this.renderGlobal.makeEntityOutlineShader();
+       
+		//VIVE
+        vrSettings.processBindings();
+		vrSettings.firstRun = false;
+		vrSettings.saveOptions();
+		//END VIVE
+        
     }
 
     /**
@@ -788,6 +1076,21 @@
         return false;
     }
 
+    public void loadClassPath(){
+    	File resourceRoot=new File("../src/resources");
+    	if(!resourceRoot.exists() || !resourceRoot.isDirectory())
+    		return;
+	    Method method = null;
+	    try {
+		    method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
+		    method.setAccessible(true);
+		    method.invoke(ClassLoader.getSystemClassLoader(), resourceRoot.toURI().toURL());
+	    } catch (NoSuchMethodException | IllegalAccessException | MalformedURLException | InvocationTargetException e) {
+		    e.printStackTrace();
+	    }
+
+    }
+
     public Framebuffer getFramebuffer()
     {
         return this.framebufferMc;
@@ -848,22 +1151,30 @@
         File file1 = new File(getMinecraft().mcDataDir, "crash-reports");
         File file2 = new File(file1, "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-client.txt");
         Bootstrap.printToSYSOUT(crashReportIn.getCompleteReport());
-
+        int retVal;
+        
         if (crashReportIn.getFile() != null)
         {
             Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + crashReportIn.getFile());
-            System.exit(-1);
+            retVal = -1;
         }
         else if (crashReportIn.saveToFile(file2))
         {
             Bootstrap.printToSYSOUT("#@!@# Game crashed! Crash report saved to: #@!@# " + file2.getAbsolutePath());
-            System.exit(-1);
+            retVal = -1;
         }
         else
         {
             Bootstrap.printToSYSOUT("#@?@# Game crashed! Crash report could not be saved. #@?@#");
-            System.exit(-2);
+            retVal = -2;
         }
+        
+        if(Reflector.forgeExists()){
+        	Object object = Reflector.call(Reflector.FMLCommonHandler_instance);
+            Reflector.call(object, Reflector.FMLCommonHandler_handleExit, new Object[] {retVal});
+        } else
+        	System.exit(retVal);
+        
     }
 
     public boolean isUnicode()
@@ -981,8 +1292,8 @@
         this.displayWidth = displaymode.getWidth();
         this.displayHeight = displaymode.getHeight();
     }
-
-    private void drawSplashScreen(TextureManager textureManagerInstance) throws LWJGLException
+    //Forge make public
+    public void drawSplashScreen(TextureManager textureManagerInstance) throws LWJGLException
     {
         ScaledResolution scaledresolution = new ScaledResolution(this);
         int i = scaledresolution.getScaleFactor();
@@ -1075,7 +1386,8 @@
      */
     public void displayGuiScreen(@Nullable GuiScreen guiScreenIn)
     {
-        if (this.currentScreen != null)
+    	
+        if (Reflector.forgeExists() == false && this.currentScreen != null)
         {
             this.currentScreen.onGuiClosed();
         }
@@ -1089,13 +1401,32 @@
             guiScreenIn = new GuiGameOver((ITextComponent)null);
         }
 
+		if (Reflector.forgeExists())
+		{
+			GuiScreen old = this.currentScreen;
+			Object event = Reflector.newInstance(Reflector.ForgeGuiOpenEvent_Constructor, new Object[] {guiScreenIn});
+
+			if (Reflector.postForgeBusEvent(event)) return;
+
+			guiScreenIn = (GuiScreen)Reflector.getFieldValue(event, Reflector.ForgeGuiOpenEvent_gui);
+			if (old != null && guiScreenIn != old)
+			{
+				old.onGuiClosed();
+			}
+		}
+		
         if (guiScreenIn instanceof GuiMainMenu || guiScreenIn instanceof GuiMultiplayer)
         {
             this.gameSettings.showDebugInfo = false;
             this.ingameGUI.getChatGUI().clearChatMessages(true);
         }
 
-        this.currentScreen = guiScreenIn;
+		// VIVE START - notify stereo provider that we're about to change screen
+        GuiHandler.onGuiScreenChanged(this.currentScreen, guiScreenIn, true);
+		// VIVE END - notify stereo provider that we're about to change screen
+
+        
+        this.currentScreen = (GuiScreen)guiScreenIn;
 
         if (guiScreenIn != null)
         {
@@ -1128,7 +1459,8 @@
     /**
      * Checks for an OpenGL error. If there is one, prints the error ID and error string.
      */
-    private void checkGLError(String message)
+    //VIVECRAFT MAKE public
+    public void checkGLError(String message)
     {
         int i = GlStateManager.glGetError();
 
@@ -1165,6 +1497,7 @@
         finally
         {
             Display.destroy();
+            MCOpenVR.destroy();
 
             if (!this.hasCrashed)
             {
@@ -1181,14 +1514,69 @@
     private void runGameLoop() throws IOException
     {
         long i = System.nanoTime();
+        
+        if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart && !this.gameSettings.hideGUI)
+        {
+        	if (!this.mcProfiler.profilingEnabled)
+        	{
+        		this.mcProfiler.clearProfiling();
+        	}
+
+        	this.mcProfiler.profilingEnabled = true;
+        }
+        else
+        {
+        	this.mcProfiler.profilingEnabled = false;
+        }
+        
         this.mcProfiler.startSection("root");
 
+        long time = System.nanoTime();
+        this.frameDelta = (time - this.prevFrameTime) / 1000000000F;
+		this.prevFrameTime = System.nanoTime();
+
         if (Display.isCreated() && Display.isCloseRequested())
         {
             this.shutdown();
         }
 
+		{
+			//avoid having to changed OpenGLHelper
+			gameSettings.fboEnable = true;
+			OpenGlHelper.framebufferSupported = true;
+		}	
+        
+		/** MINECRIFT */ // setup the display, render buffers, shaders etc.
+		this.frameIndex++;
+		
+		try {
+			stereoProvider.setupRenderConfiguration();
+		} catch (RenderConfigException e) {
+			GL11.glViewport(0, 0, this.displayWidth, this.displayHeight);
+			GlStateManager.clearColor(0, 0, 0, 1);
+			GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+			entityRenderer.displayNotificationText("Render Setup Failed " + " " + e.error, "", "", this.displayWidth, this.displayHeight, false, true);
+			Display.update();
+			System.out.println(e.title);
+			System.out.println(e.error);
+			return;
+		} catch (Exception e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+
+		/** END MINECRIFT */
+		
         this.timer.updateTimer();
+        
+        //VIVECRAFT
+    	this.mcProfiler.startSection("Poll");
+		// Poll sensors
+			MCOpenVR.poll(frameIndex);
+		this.mcProfiler.endSection();
+        
+		vrPlayer.postPoll();
+		
         this.mcProfiler.startSection("scheduledExecutables");
 
         synchronized (this.scheduledTasks)
@@ -1200,69 +1588,196 @@
         }
 
         this.mcProfiler.endSection();
+        		
+	
+        
         long l = System.nanoTime();
         this.mcProfiler.startSection("tick");
-
+       
         for (int j = 0; j < Math.min(10, this.timer.elapsedTicks); ++j)
         {
+            //VIVECRAFT
+            vrPlayer.preTick();
+            //
             this.runTick();
-        }
-
+            //VIVECRAFT
+            vrPlayer.postTick();
+            //
+        }
+       
+        
+        //VIVECRAFT
+		try {
+			stereoProvider.setupRenderConfiguration();
+		} catch (Exception e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		//
+        
+				
         this.mcProfiler.endStartSection("preRenderErrors");
         long i1 = System.nanoTime() - l;
         this.checkGLError("Pre render");
-        this.mcProfiler.endStartSection("sound");
-        this.mcSoundHandler.setListener(this.player, this.timer.renderPartialTicks);
-        this.mcProfiler.endSection();
-        this.mcProfiler.startSection("render");
-        GlStateManager.pushMatrix();
-        GlStateManager.clear(16640);
-        this.framebufferMc.bindFramebuffer(true);
-        this.mcProfiler.startSection("display");
-        GlStateManager.enableTexture2D();
-        this.mcProfiler.endSection();
-
-        if (!this.skipRenderWorld)
-        {
-            this.mcProfiler.endStartSection("gameRenderer");
-            this.entityRenderer.updateCameraAndRender(this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks, i);
-            this.mcProfiler.endStartSection("toasts");
-            this.toastGui.drawToast(new ScaledResolution(this));
-            this.mcProfiler.endSection();
-        }
-
+        
+        float par1 = this.isGamePaused ? this.renderPartialTicksPaused : this.timer.renderPartialTicks;
+        
+		this.mcProfiler.endStartSection("Gui");
+		
+        GlStateManager.depthMask(true);
+        GlStateManager.colorMask(true, true, true, true);
+		
+		// Render GUI to FBO if necessary
+			this.framebufferMc = GuiHandler.guiFramebuffer; //draw to 2d gui.
+			this.framebufferMc.bindFramebuffer(true);
+						
+			this.entityRenderer.drawFramebuffer(par1, i1);   // VIVE - added param for debug info
+
+			if(KeyboardHandler.Showing && !this.vrSettings.physicalKeyboard) {
+				this.framebufferMc = KeyboardHandler.Framebuffer; 
+				this.framebufferMc.bindFramebuffer(true);
+				this.entityRenderer.drawScreen(par1, KeyboardHandler.UI);            
+			}
+			
+			if(RadialHandler.Showing) {
+				this.framebufferMc = RadialHandler.Framebuffer; 
+				this.framebufferMc.bindFramebuffer(true);
+				this.entityRenderer.drawScreen(par1, RadialHandler.UI);            
+			}
+
+			checkGLError("post 2d ");
+			this.mcProfiler.endSection();
+
+        //VIVECRAFT
+		this.mcProfiler.startSection("preRender");
+        vrPlayer.preRender(par1);
         this.mcProfiler.endSection();
+        //
+        
+		this.mcProfiler.startSection("sound");
+		//this.mcSoundHandler.setListener(this.player, this.timer.renderPartialTicks);
+		updateSoundListener(); // we update the sound listener from the HMD info
+		this.mcProfiler.endSection();
+	
+	
+		this.mcProfiler.startSection("hmdSampling");
+
+		if (hmdPosSamples.size() == hmdAvgLength)
+			hmdPosSamples.removeFirst();
+		if (hmdYawSamples.size() == hmdAvgLength)
+			hmdYawSamples.removeFirst();
+
+		float yaw = vrPlayer.vrdata_room_pre.hmd.getYaw();
+		if (yaw < 0) yaw += 360;
+		hmdYawTotal += angleDiff(yaw, hmdYawLast);
+		hmdYawLast = yaw;
+		if (Math.abs(angleNormalize(hmdYawTotal) - hmdYawLast) > 1 || hmdYawTotal > 100000) {
+			hmdYawTotal = hmdYawLast;
+			System.out.println("HMD yaw desync/overflow corrected");
+		}
+
+		hmdPosSamples.add(vrPlayer.vrdata_room_pre.hmd.getPosition());
+		float yawAvg = 0;
+		if(hmdYawSamples.size() > 0){
+			for (float f : hmdYawSamples) {
+				yawAvg += f;
+			}
+			yawAvg /= hmdYawSamples.size();
+		}
+		if( Math.abs((hmdYawTotal - yawAvg)) > 20) trigger = true;
+		if( Math.abs((hmdYawTotal - yawAvg)) < 1) trigger = false;
+		if(trigger || hmdYawSamples.isEmpty())
+			hmdYawSamples.add(hmdYawTotal);
+
+		this.mcProfiler.endSection(); //hmd sampling
+		
+	    //VIVECRAFT RENDERING MAIN
+			if (minecriftDebug) print("FrameIndex: " + frameIndex);
+		
+			boolean shouldupdate = true;
+			
+//			int passes = 2;
+//			
+//			if( this.vrSettings.displayMirrorMode == VRSettings.MIRROR_FIRST_PERSON ){
+//				passes = 3;
+//			} else if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_MIXED_REALITY || this.vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON) {
+//				passes = 4;
+//			}
+//			
+			int w, h;
+			
+            List<RenderPass> passes = this.stereoProvider.getRenderPasses();
+			
+			/** Minecrift - main stereo render loop **/
+            for (RenderPass pass : passes)
+			{
+                this.currentPass = pass;
+                switch (pass) {
+                    case LEFT:
+                    case RIGHT:
+                        this.framebufferMc = stereoProvider.framebufferVrRender;
+                        break;
+                    case CENTER:
+                        this.framebufferMc = stereoProvider.framebufferUndistorted;
+                        break;
+                    case THIRD:
+                        this.framebufferMc = stereoProvider.framebufferMR;
+						break;
+				}
+
+                this.mcProfiler.startSection("Eye:" + currentPass.ordinal());
+                    this.mcProfiler.startSection("setup");
+                        this.framebufferMc.bindFramebuffer(true);	//draw to main texture for every pass
+                    this.mcProfiler.endSection();
+                        shouldupdate = renderSingleView(pass.ordinal(), par1);
+                this.mcProfiler.endSection(); //eye
+
+    			if(grabScreenShot > 0){
+    				grabScreenShot--;
+    				if(grabScreenShot == 0){
+    					this.framebufferMc.unbindFramebuffer();
+    					OpenGlHelper.fbo = false;
+    	            	this.ingameGUI.getChatGUI().printChatMessage(ScreenShotHelper.saveScreenshot(this.mcDataDir, this.displayWidth, this.displayHeight, this.getFramebuffer()));
+    	            	OpenGlHelper.fbo = true;
+    				}
+    			}
+			} //end per eye rendering.
+
+			//VIVECRAFT
+			vrPlayer.postRender(par1);
+			//
+			
+            if (this.vrSettings.displayMirrorMode == VRSettings.MIRROR_OFF && MCOpenVR.isHMDTracking()){
+                GlStateManager.viewport(0, 0, this.displayWidth, this.displayHeight);
+				shouldupdate = true;
+				this.framebufferMc.unbindFramebuffer();	//draw directly to window
+				GlStateManager.clearColor(0, 0, 0, 1);
+				GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);
+				entityRenderer.displayNotificationText("Mirror is OFF", "", "", this.displayWidth, this.displayHeight, false, true);
+			}
+
+			mcProfiler.startSection("GameWindowEvents");			
+				Display.processMessages();
+				if (shouldupdate) Display.update(false);
+
+			mcProfiler.endSection();
+			
+			mcProfiler.startSection("Display/Reproject");
+			try {
+				this.stereoProvider.endFrame();
+			} catch (Exception e) {
+				LOGGER.error(e.toString());
+			}
+
+			mcProfiler.endSection();
+
+		
+			////END MAIN VIVECRAFT RENDERING
+		
 
-        if (this.gameSettings.showDebugInfo && this.gameSettings.showDebugProfilerChart && !this.gameSettings.hideGUI)
-        {
-            if (!this.mcProfiler.profilingEnabled)
-            {
-                this.mcProfiler.clearProfiling();
-            }
-
-            this.mcProfiler.profilingEnabled = true;
-            this.displayDebugInfo(i1);
-        }
-        else
-        {
-            this.mcProfiler.profilingEnabled = false;
-            this.prevFrameTime = System.nanoTime();
-        }
 
-        this.framebufferMc.unbindFramebuffer();
-        GlStateManager.popMatrix();
-        GlStateManager.pushMatrix();
-        this.framebufferMc.framebufferRender(this.displayWidth, this.displayHeight);
-        GlStateManager.popMatrix();
-        GlStateManager.pushMatrix();
-        this.entityRenderer.renderStreamIndicator(this.timer.renderPartialTicks);
-        GlStateManager.popMatrix();
-        this.mcProfiler.startSection("root");
-        this.updateDisplay();
-        Thread.yield();
-        this.checkGLError("Post render");
         ++this.fpsCounter;
-        boolean flag = this.isSingleplayer() && this.currentScreen != null && this.currentScreen.doesGuiPauseGame() && !this.integratedServer.getPublic();
+        boolean flag = this.isSingleplayer() && ((this.currentScreen != null && this.currentScreen.doesGuiPauseGame()) || MCOpenVR.paused) && !this.integratedServer.getPublic();
 
         if (this.isGamePaused != flag)
         {
@@ -1297,14 +1812,14 @@
             }
         }
 
-        if (this.isFramerateLimitBelowMax())
-        {
-            this.mcProfiler.startSection("fpslimit_wait");
-            Display.sync(this.getLimitFramerate());
-            this.mcProfiler.endSection();
-        }
+//        if (this.isFramerateLimitBelowMax())
+//        {
+//            this.mcProfiler.startSection("fpslimit_wait");
+//            Display.sync(this.getLimitFramerate());
+//            this.mcProfiler.endSection();
+//        }
 
-        this.mcProfiler.endSection();
+        this.mcProfiler.endSection(); //root
     }
 
     public void updateDisplay()
@@ -1422,7 +1937,7 @@
     /**
      * Parameter appears to be unused
      */
-    private void displayDebugInfo(long elapsedTicksTime)
+    public void displayDebugInfo(long elapsedTicksTime)
     {
         if (this.mcProfiler.profilingEnabled)
         {
@@ -1432,7 +1947,7 @@
             GlStateManager.matrixMode(5889);
             GlStateManager.enableColorMaterial();
             GlStateManager.loadIdentity();
-            GlStateManager.ortho(0.0D, (double)this.displayWidth, (double)this.displayHeight, 0.0D, 1000.0D, 3000.0D);
+            GlStateManager.ortho(displayWidth/2, (double)this.displayWidth, (double)this.displayHeight, dispLastHeight/3, 1000.0D, 3000.0D);
             GlStateManager.matrixMode(5888);
             GlStateManager.loadIdentity();
             GlStateManager.translate(0.0F, 0.0F, -2000.0F);
@@ -1559,7 +2074,8 @@
                 }
 
                 this.inGameHasFocus = true;
-                this.mouseHelper.grabMouseCursor();
+	            if(vrSettings.seated)
+                    this.mouseHelper.grabMouseCursor(); // NO. BAD.
                 this.displayGuiScreen((GuiScreen)null);
                 this.leftClickCounter = 10000;
             }
@@ -1594,84 +2110,98 @@
         }
     }
 
-    private void sendClickBlockToController(boolean leftClick)
+    private void sendClickBlockToController(boolean inGame)
     {
-        if (!leftClick)
+        if (!inGame)
         {
             this.leftClickCounter = 0;
         }
 
         if (this.leftClickCounter <= 0 && !this.player.isHandActive())
         {
-            if (leftClick && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == RayTraceResult.Type.BLOCK)
+            if (inGame && this.objectMouseOver != null && this.objectMouseOver.typeOfHit == RayTraceResult.Type.BLOCK)
             {
                 BlockPos blockpos = this.objectMouseOver.getBlockPos();
 
-                if (this.world.getBlockState(blockpos).getMaterial() != Material.AIR && this.playerController.onPlayerDamageBlock(blockpos, this.objectMouseOver.sideHit))
+                //Forge changes this from a material check to isAirBlock...
+                if (!this.world.isAirBlock(blockpos) && this.playerController.onPlayerDamageBlock(blockpos, this.objectMouseOver.sideHit))
                 {
-                    this.effectRenderer.addBlockHitEffects(blockpos, this.objectMouseOver.sideHit);
+                	if(Reflector.forgeExists())
+                		//y u gotta be different?
+                		Reflector.call(this.effectRenderer, Reflector.ForgeParticleManager_addBlockHitEffects, blockpos, this.objectMouseOver);
+                	else
+                		this.effectRenderer.addBlockHitEffects(blockpos, this.objectMouseOver.sideHit);
+                	
                     this.player.swingArm(EnumHand.MAIN_HAND);
                 }
             }
-            else
-            {
-                this.playerController.resetBlockRemoving();
-            }
+
+            //VIVE SUPPORT HAND SWINING
+//            else
+//            {
+//                this.playerController.resetBlockRemoving();
+//            }
         }
     }
 
-    private void clickMouse()
-    {
-        if (this.leftClickCounter <= 0)
-        {
-            if (this.objectMouseOver == null)
-            {
-                LOGGER.error("Null returned as 'hitResult', this shouldn't happen!");
+    //VIVE CHANGES THIS WHOLE... THING
+    @SuppressWarnings("fallthrough")
+	private void clickMouse()
+    {
+    	if (this.leftClickCounter <= 0)
+    	{
+    		if (this.objectMouseOver == null)
+    		{
+    			// LOGGER.error("Null returned as \'hitResult\', this shouldn\'t happen!");
+
+    			if (this.playerController.isNotCreative())
+    			{
+    				this.leftClickCounter = 10;
+    			}
+    		}
+    		else if (!this.player.isRowingBoat())
+    		{
+    			switch (this.objectMouseOver.typeOfHit)
+    			{
+    			case ENTITY:
+    				this.playerController.attackEntity(this.player, this.objectMouseOver.entityHit);
+    				break;
+
+    			case BLOCK:
+    				BlockPos blockpos = this.objectMouseOver.getBlockPos();
+
+    				if (!this.world.isAirBlock(blockpos))
+    				{
+    					this.playerController.clickBlock(blockpos, this.objectMouseOver.sideHit);
+
+    					break;
+    				}
+
+    			case MISS:
+    				if (this.playerController.isNotCreative())
+    				{
+    					this.leftClickCounter = 10;
+    				}
+
+    				this.player.resetCooldown();
+    				if(Reflector.forgeExists())
+    					Reflector.callVoid(Reflector.ForgeHooks_onEmptyLeftClick, this.player);
+    				break;
+    			}
+
+    			this.player.swingArm(EnumHand.MAIN_HAND);
+    		}
+    	}
 
-                if (this.playerController.isNotCreative())
-                {
-                    this.leftClickCounter = 10;
-                }
-            }
-            else if (!this.player.isRowingBoat())
-            {
-                switch (this.objectMouseOver.typeOfHit)
-                {
-                    case ENTITY:
-                        this.playerController.attackEntity(this.player, this.objectMouseOver.entityHit);
-                        break;
-
-                    case BLOCK:
-                        BlockPos blockpos = this.objectMouseOver.getBlockPos();
+    	if(this.playerController.isNotCreative())    
+    		this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown());
 
-                        if (this.world.getBlockState(blockpos).getMaterial() != Material.AIR)
-                        {
-                            this.playerController.clickBlock(blockpos, this.objectMouseOver.sideHit);
-                            break;
-                        }
-
-                    case MISS:
-                        if (this.playerController.isNotCreative())
-                        {
-                            this.leftClickCounter = 10;
-                        }
-
-                        this.player.resetCooldown();
-                }
-
-                this.player.swingArm(EnumHand.MAIN_HAND);
-            }
-        }
     }
 
     @SuppressWarnings("incomplete-switch")
-
-    /**
-     * Called when user clicked he's mouse right button (place)
-     */
-    private void rightClickMouse()
+	public void rightClickMouse()
     {
-        if (!this.playerController.getIsHittingBlock())
+        if (!this.playerController.getIsHittingBlock() || vrSettings.seated == false) //VIVE
         {
             this.rightClickDelayTimer = 4;
 
@@ -1679,7 +2209,7 @@
             {
                 if (this.objectMouseOver == null)
                 {
-                    LOGGER.warn("Null returned as 'hitResult', this shouldn't happen!");
+                    //LOGGER.warn("Null returned as \'hitResult\', this shouldn\'t happen!");
                 }
 
                 for (EnumHand enumhand : EnumHand.values())
@@ -1706,7 +2236,7 @@
                             case BLOCK:
                                 BlockPos blockpos = this.objectMouseOver.getBlockPos();
 
-                                if (this.world.getBlockState(blockpos).getMaterial() != Material.AIR)
+                                if (!this.world.isAirBlock(blockpos)) //Forge DOES NOT change this to isairblock but it prolly is supposed to... right?
                                 {
                                     int i = itemstack.getCount();
                                     EnumActionResult enumactionresult = this.playerController.processRightClickBlock(this.player, this.world, blockpos, this.objectMouseOver.sideHit, this.objectMouseOver.hitVec, enumhand);
@@ -1714,10 +2244,14 @@
                                     if (enumactionresult == EnumActionResult.SUCCESS)
                                     {
                                         this.player.swingArm(enumhand);
+                                        
+                                        if(Reflector.forgeExists())
+                                        	if (itemstack.isEmpty() && (this.objectMouseOver == null || this.objectMouseOver.typeOfHit == RayTraceResult.Type.MISS)) 
+                                        		Reflector.callVoid(Reflector.ForgeHooks_onEmptyClick,this.player, enumhand);
 
                                         if (!itemstack.isEmpty() && (itemstack.getCount() != i || this.playerController.isInCreativeMode()))
                                         {
-                                            this.entityRenderer.itemRenderer.resetEquippedProgress(enumhand);
+                                        	this.entityRenderer.itemRenderer.resetEquippedProgress(enumhand);
                                         }
 
                                         return;
@@ -1745,7 +2279,7 @@
         {
             this.fullscreen = !this.fullscreen;
             this.gameSettings.fullScreen = this.fullscreen;
-
+            this.gameSettings.saveOptions();
             if (this.fullscreen)
             {
                 this.updateDisplayMode();
@@ -1801,29 +2335,16 @@
     /**
      * Called to resize the current screen.
      */
-    private void resize(int width, int height)
+    public void resize(int width, int height) //Forge make public
     {
-        this.displayWidth = Math.max(1, width);
-        this.displayHeight = Math.max(1, height);
-
-        if (this.currentScreen != null)
-        {
-            ScaledResolution scaledresolution = new ScaledResolution(this);
-            this.currentScreen.onResize(this, scaledresolution.getScaledWidth(), scaledresolution.getScaledHeight());
-        }
-
-        this.loadingScreen = new LoadingScreenRenderer(this);
-        this.updateFramebufferSize();
+    	if (this.stereoProvider != null)
+    		this.stereoProvider.reinitFrameBuffers("Resize");
     }
 
     private void updateFramebufferSize()
     {
-        this.framebufferMc.createBindFramebuffer(this.displayWidth, this.displayHeight);
-
-        if (this.entityRenderer != null)
-        {
-            this.entityRenderer.updateShaderGroupSize(this.displayWidth, this.displayHeight);
-        }
+    	if (this.stereoProvider != null)
+    		this.stereoProvider.reinitFrameBuffers("Update Framebuffer Size");
     }
 
     /**
@@ -1839,11 +2360,21 @@
      */
     public void runTick() throws IOException
     {
+	    this.tickCounter++;
+	    
         if (this.rightClickDelayTimer > 0)
         {
             --this.rightClickDelayTimer;
         }
-
+        
+        Object fmlCommonHandler = null;
+        boolean hasForge = Reflector.forgeExists();
+        
+		if( hasForge) {
+			fmlCommonHandler = Reflector.call( Reflector.FMLCommonHandler_instance);
+			Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onPreClientTick);
+		}
+        
         this.mcProfiler.startSection("gui");
 
         if (!this.isGamePaused)
@@ -1863,10 +2394,17 @@
 
         this.mcProfiler.endStartSection("textures");
 
-        if (this.world != null)
-        {
+		// VanillaFix support
+		if (this.world == null && this.menuWorldRenderer != null) {
+			this.menuWorldRenderer.pushVisibleTextures();
+		}
+		// End VanillaFix support
+
+        // VIVE: nah we wanna tick textures on the main menu too
+        //if (this.world != null)
+        //{
             this.renderEngine.tick();
-        }
+        //}
 
         if (this.currentScreen == null && this.player != null)
         {
@@ -1930,25 +2468,46 @@
                 }
             }
         }
+        
+        //Vivecraft
+        this.mcProfiler.endStartSection("vrProcessInputs");
+        MCOpenVR.processInputs();
+        MCOpenVR.processBindings();
+        ///
 
         if (this.currentScreen == null || this.currentScreen.allowUserInput)
         {
-            this.mcProfiler.endStartSection("mouse");
-            this.runTickMouse();
+        	this.mcProfiler.endStartSection("mouse");
+        	this.runTickMouse();
 
-            if (this.leftClickCounter > 0)
-            {
-                --this.leftClickCounter;
-            }
+        	if (this.leftClickCounter > 0)
+        	{
+        		--this.leftClickCounter;
+        	}
+
+        	this.mcProfiler.endStartSection("keyboard");
+        	this.runTickKeyboard();
+        }
+
+        //Vivecraft
+        this.mcProfiler.endStartSection("vrButtonMappingsTick");
+        for (VRButtonMapping mapping : this.vrSettings.buttonMappings.values()) {
+        	mapping.tick();
+        }   
+
+        this.mcProfiler.endStartSection("vrPostProcessInputs");
+        MCOpenVR.postProcessBindings();
+        
+    	if(vrSettings.displayMirrorMode == VRSettings.MIRROR_MIXED_REALITY || vrSettings.displayMirrorMode == VRSettings.MIRROR_THIRD_PERSON)
+    		VRHotkeys.handleMRKeys();
 
-            this.mcProfiler.endStartSection("keyboard");
-            this.runTickKeyboard();
-        }
+        ///
 
         if (this.world != null)
         {
             if (this.player != null)
             {
+            	
                 ++this.joinPlayerCounter;
 
                 if (this.joinPlayerCounter == 30)
@@ -1956,10 +2515,14 @@
                     this.joinPlayerCounter = 0;
                     this.world.joinEntityInSurroundings(this.player);
                 }
+                
+                if(hasForge)
+                	Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_fireMouseInput);
+
             }
 
             this.mcProfiler.endStartSection("gameRenderer");
-
+    		           
             if (!this.isGamePaused)
             {
                 this.entityRenderer.updateRenderer();
@@ -1989,6 +2552,9 @@
             this.entityRenderer.stopUseShader();
         }
 
+	    if (this.menuWorldRenderer != null) this.menuWorldRenderer.updateTorchFlicker();
+	    PlayerModelController.getInstance().tick();
+
         if (!this.isGamePaused)
         {
             this.mcMusicTicker.update();
@@ -2043,8 +2609,12 @@
             this.mcProfiler.endStartSection("pendingConnection");
             this.myNetworkManager.processReceivedPackets();
         }
-
+        
+        
         this.mcProfiler.endSection();
+        if(hasForge)
+        	Reflector.callVoid(fmlCommonHandler, Reflector.FMLCommonHandler_onPostClientTick);
+
         this.systemTime = getSystemTime();
     }
 
@@ -2079,6 +2649,14 @@
                 this.currentScreen.handleKeyboardInput();
             }
 
+			/** MINECRIFT */
+			
+			{
+				if (VRHotkeys.handleKeyboardInputs(this))
+					continue;
+			}
+			/** END MINECRIFT */
+            
             boolean flag = Keyboard.getEventKeyState();
 
             if (flag)
@@ -2088,6 +2666,8 @@
                     this.entityRenderer.switchUseShader();
                 }
 
+                if(i==1) KeyboardHandler.setOverlayShowing(false);
+                
                 boolean flag1 = false;
 
                 if (this.currentScreen == null)
@@ -2095,6 +2675,7 @@
                     if (i == 1)
                     {
                         this.displayInGameMenu();
+
                     }
 
                     flag1 = Keyboard.isKeyDown(61) && this.processKeyF3(i);
@@ -2102,7 +2683,7 @@
 
                     if (i == 59)
                     {
-                        this.gameSettings.hideGUI = !this.gameSettings.hideGUI;
+						this.gameSettings.hideGUI = !this.gameSettings.hideGUI;
                     }
                 }
 
@@ -2150,6 +2731,11 @@
                     }
                 }
             }
+            
+            //Forge
+            if(Reflector.forgeExists())
+            	Reflector.callVoid(Reflector.call( Reflector.FMLCommonHandler_instance), Reflector.FMLCommonHandler_fireKeyInput);
+            //
         }
 
         this.processKeyBinds();
@@ -2253,22 +2839,10 @@
     private void processKeyBinds()
     {
         for (; this.gameSettings.keyBindTogglePerspective.isPressed(); this.renderGlobal.setDisplayListEntitiesDirty())
-        {
-            ++this.gameSettings.thirdPersonView;
-
-            if (this.gameSettings.thirdPersonView > 2)
-            {
-                this.gameSettings.thirdPersonView = 0;
-            }
-
-            if (this.gameSettings.thirdPersonView == 0)
-            {
-                this.entityRenderer.loadEntityShader(this.getRenderViewEntity());
-            }
-            else if (this.gameSettings.thirdPersonView == 1)
-            {
-                this.entityRenderer.loadEntityShader((Entity)null);
-            }
+        {      	
+            vrSettings.setOptionValue(VrOptions.MIRROR_DISPLAY, vrSettings.displayMirrorMode);
+            this.ingameGUI.getChatGUI().printChatMessage(new TextComponentString(vrSettings.getKeyBinding(VrOptions.MIRROR_DISPLAY)));
+            
         }
 
         while (this.gameSettings.keyBindSmoothCamera.isPressed())
@@ -2335,23 +2909,34 @@
         boolean flag2 = this.gameSettings.chatVisibility != EntityPlayer.EnumChatVisibility.HIDDEN;
 
         if (flag2)
-        {
-            while (this.gameSettings.keyBindChat.isPressed())
-            {
-                this.displayGuiScreen(new GuiChat());
-            }
-
+        {		
+    		if(this.currentScreen instanceof GuiChat){
+    			while (this.gameSettings.keyBindChat.isPressed())
+    			{
+    				this.displayGuiScreen(null);
+    			}
+    		} else {
+    			while (this.gameSettings.keyBindChat.isPressed())
+    			{
+    				this.displayGuiScreen(new GuiChat());
+    			}
+    		}
+        	
             if (this.currentScreen == null && this.gameSettings.keyBindCommand.isPressed())
             {
                 this.displayGuiScreen(new GuiChat("/"));
             }
         }
 
+    	boolean nope = false;
+        if(climbTracker.isClimbeyClimb() && (this.objectMouseOver==null || this.objectMouseOver.entityHit==null)) nope = true;
+        
         if (this.player.isHandActive())
         {
-            if (!this.gameSettings.keyBindUseItem.isKeyDown())
+            if (!this.gameSettings.keyBindUseItem.isKeyDown() && (bowTracker.isActive(player) == false || vrSettings.seated))
             {
-                this.playerController.onStoppedUsingItem(this.player);
+	            if(!autoFood.isEating())
+                    this.playerController.onStoppedUsingItem(this.player);
             }
 
             label109:
@@ -2377,13 +2962,23 @@
                 }
             }
         }
-        else
+        else //not using item
         {
-            while (this.gameSettings.keyBindAttack.isPressed())
-            {
-                this.clickMouse();
-            }
-
+        	//VIVE SUPPORT HAND SWINGING
+        	if (!nope && this.gameSettings.keyBindAttack.isPressed() && currentScreen == null)
+        	{
+        		this.clickMouse();
+        		lastClick = true;
+        	} else if (!this.gameSettings.keyBindAttack.isKeyDown()){
+        		this.leftClickCounter = 0;
+        		if (lastClick)
+        		{
+        			this.playerController.resetBlockRemoving();
+        		}
+        		lastClick = false;
+        	}
+            ///END VIVE
+            
             while (this.gameSettings.keyBindUseItem.isPressed())
             {
                 this.rightClickMouse();
@@ -2395,18 +2990,23 @@
             }
         }
 
-        if (this.gameSettings.keyBindUseItem.isKeyDown() && this.rightClickDelayTimer == 0 && !this.player.isHandActive())
-        {
+        if (this.gameSettings.keyBindUseItem.isKeyDown() && this.rightClickDelayTimer == 0 && !this.player.isHandActive() && currentScreen == null)
+        { //someone tell me what this is for.
             this.rightClickMouse();
         }
 
-        this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown() && this.inGameHasFocus);
+       if(!(!(nope==false))) this.sendClickBlockToController(this.currentScreen == null && this.gameSettings.keyBindAttack.isKeyDown());
     }
 
     private void runTickMouse() throws IOException
     {
         while (Mouse.next())
         {
+        	
+			if (Reflector.forgeExists()) {
+				if (Reflector.callBoolean(Reflector.ForgeHooksClient_postMouseEvent)) continue;
+			}
+			
             int i = Mouse.getEventButton();
             KeyBinding.setKeyBindState(i - 100, Mouse.getEventButtonState());
 
@@ -2421,6 +3021,11 @@
                     KeyBinding.onTick(i - 100);
                 }
             }
+            
+				if(!(GuiHandler.controllerMouseValid)){
+					if (mouseHelper.deltaX > 0 || mouseHelper.deltaY> 0 )
+						GuiHandler.controllerMouseValid = true;
+					}
 
             long j = getSystemTime() - this.systemTime;
 
@@ -2456,6 +3061,10 @@
                     {
                         this.setIngameFocus();
                     }
+                    else if (this.inGameHasFocus && !Display.isActive())
+                    {
+                        this.setIngameNotInFocus();
+                    }
                 }
                 else if (this.currentScreen != null)
                 {
@@ -2475,6 +3084,15 @@
      */
     public void launchIntegratedServer(String folderName, String worldName, @Nullable WorldSettings worldSettingsIn)
     {
+		Object fmlClientHandler = null;
+		if( Reflector.FMLClientHandler_instance.exists()) {
+			fmlClientHandler = Reflector.call( Reflector.FMLClientHandler_instance);
+		}
+		if( fmlClientHandler != null) {
+			Reflector.callVoid(fmlClientHandler, Reflector.FMLClientHandler_startIntegratedServer, new Object[] {folderName, worldName, worldSettingsIn});
+		}
+		
+    	integratedServerLaunchInProgress = true;
         this.loadWorld((WorldClient)null);
         System.gc();
         ISaveHandler isavehandler = this.saveLoader.getSaveLoader(folderName, false);
@@ -2517,6 +3135,16 @@
 
         while (!this.integratedServer.serverIsInRunLoop())
         {
+			if (Reflector.forgeExists())
+			{
+				if (!Reflector.callBoolean(Reflector.FMLStartupQuery_check))
+				{
+					loadWorld(null);
+					displayGuiScreen(null);
+					return;
+				}
+			}
+			
             String s = this.integratedServer.getUserMessage();
 
             if (s != null)
@@ -2537,12 +3165,20 @@
                 ;
             }
         }
-
+        integratedServerLaunchInProgress = false;
         this.displayGuiScreen(new GuiScreenWorking());
         SocketAddress socketaddress = this.integratedServer.getNetworkSystem().addLocalEndpoint();
         NetworkManager networkmanager = NetworkManager.provideLocalClient(socketaddress);
         networkmanager.setNetHandler(new NetHandlerLoginClient(networkmanager, this, (GuiScreen)null));
-        networkmanager.sendPacket(new C00Handshake(socketaddress.toString(), 0, EnumConnectionState.LOGIN));
+        networkmanager.sendPacket(new C00Handshake(socketaddress.toString(), 0, EnumConnectionState.LOGIN, Reflector.forgeExists()));
+        //Forge thing
+        if(Reflector.forgeExists())
+        	if (!Reflector.callBoolean(this.getSession(), Reflector.ForgeSession_hasCachedProperties))
+        	{
+        		com.mojang.authlib.GameProfile gameProfile = this.getSession().getProfile();
+        		gameProfile = sessionService.fillProfileProperties(gameProfile, true); //Forge: Fill profile properties upon game load. Fixes MC-52974.
+        		Reflector.call(this.getSession(), Reflector.ForgeSession_setProperties, new Object[]{gameProfile.getProperties()});
+        	}
         networkmanager.sendPacket(new CPacketLoginStart(this.getSession().getProfile()));
         this.myNetworkManager = networkmanager;
     }
@@ -2552,6 +3188,9 @@
      */
     public void loadWorld(@Nullable WorldClient worldClientIn)
     {
+		// VIVE START - reset room origin
+		vrPlayer.setRoomOrigin(0, 0, 0, true);
+		// VIVE END - reset room origin
         this.loadWorld(worldClientIn, "");
     }
 
@@ -2560,6 +3199,11 @@
      */
     public void loadWorld(@Nullable WorldClient worldClientIn, String loadingMessage)
     {
+		if (this.world != null && Reflector.EventBus.exists())
+		{
+			Reflector.postForgeBusEvent(Reflector.ForgeWorldEvent_Unload_Constructor, this.world);
+		}
+    	
         if (worldClientIn == null)
         {
             NetHandlerPlayClient nethandlerplayclient = this.getConnection();
@@ -2572,6 +3216,22 @@
             if (this.integratedServer != null && this.integratedServer.isAnvilFileSet())
             {
                 this.integratedServer.initiateShutdown();
+            	//Forge
+            	if(Reflector.forgeExists()){
+            		if (loadingScreen != null && this.running)
+            		{
+            			this.loadingScreen.displayLoadingString(I18n.format("forge.client.shutdown.internal"));
+            		}
+            		while (!integratedServer.isServerStopped())
+            		{
+            			try
+            			{
+            				Thread.sleep(10);
+            			}
+            			catch (InterruptedException ie) {}
+            		}
+            	}
+            	//
             }
 
             this.integratedServer = null;
@@ -2595,6 +3255,11 @@
             this.ingameGUI.resetPlayersOverlayFooterHeader();
             this.setServerData((ServerData)null);
             this.integratedServerIsRunning = false;
+			//Forge
+            if(Reflector.forgeExists()) {
+				Reflector.callVoid(Reflector.call( Reflector.FMLClientHandler_instance), Reflector.FMLClientHandler_handleClientWorldClosing, new Object[]{this.world});
+			}
+            //
         }
 
         this.mcSoundHandler.stopSounds();
@@ -2665,6 +3330,7 @@
         EntityPlayerSP entityplayersp = this.player;
         this.player = this.playerController.createPlayer(this.world, this.player == null ? new StatisticsManager() : this.player.getStatFileWriter(), this.player == null ? new RecipeBook() : this.player.getRecipeBook());
         this.player.getDataManager().setEntryValues(entityplayersp.getDataManager().getAll());
+		this.player.updateSyncFields(entityplayersp); // Forge: fix MC-10657
         this.player.dimension = dimension;
         this.renderViewEntity = this.player;
         this.player.preparePlayerToSpawn();
@@ -2701,6 +3367,7 @@
         return instance == null || !instance.gameSettings.hideGUI;
     }
 
+    //unused
     public static boolean isFancyGraphicsEnabled()
     {
         return instance != null && instance.gameSettings.fancyGraphics;
@@ -2717,8 +3384,14 @@
     /**
      * Called when user clicked he's mouse middle button (pick block)
      */
-    private void middleClickMouse()
+    public void middleClickMouse() //VIVECRAFT PUBLIC
     {
+    	
+    	if(Reflector.forgeExists() && this.objectMouseOver != null){
+    		Reflector.call(Reflector.ForgeHooks_onPickBlock, new Object[]{this.objectMouseOver,this.player,this.world});
+			return;
+    	}
+    	
         if (this.objectMouseOver != null && this.objectMouseOver.typeOfHit != RayTraceResult.Type.MISS)
         {
             boolean flag = this.player.capabilities.isCreativeMode;
@@ -2882,7 +3555,8 @@
         }
     }
 
-    private ItemStack storeTEInStack(ItemStack stack, TileEntity te)
+    //Forge make public
+   public ItemStack storeTEInStack(ItemStack stack, TileEntity te)
     {
         NBTTagCompound nbttagcompound = te.writeToNBT(new NBTTagCompound());
 
@@ -3212,6 +3886,11 @@
      */
     public static int getGLMaximumTextureSize()
     {
+    	//Forge
+    	if(Reflector.forgeExists())
+    		return Reflector.callInt(Reflector.SplashProgress_getMaxTextureSize);
+    	//
+    	
         for (int i = 16384; i > 0; i >>= 1)
         {
             GlStateManager.glTexImage2D(32868, 0, 6408, i, i, 0, 6408, 5121, (IntBuffer)null);
@@ -3400,7 +4079,7 @@
     }
 
     public void dispatchKeypresses()
-    {
+    { //forge does some shit to this, I dont care.
         int i = Keyboard.getEventKey() == 0 ? Keyboard.getEventCharacter() + 256 : Keyboard.getEventKey();
 
         if (i != 0 && !Keyboard.isRepeatEvent())
@@ -3582,4 +4261,762 @@
     {
         return this.tutorial;
     }
+    
+    //VIVECRAFT ADDITIONS **************************************************************************
+    
+   
+	public void printChatMessage(String msg)
+	{
+		if (this.world != null) {
+			ITextComponent chatText = new TextComponentString(msg);
+			this.ingameGUI.getChatGUI().printChatMessage(chatText);
+		}
+	}
+    
+	public Matrix4f getMRTransform(){
+		//I swear to god this should be correct for column-major and post-multiplication for view matrix
+
+		Vec3d roomo = vrPlayer.vrdata_world_render.origin;
+
+		FloatBuffer conrot = null;	
+
+		Object temp;
+		if(MCOpenVR.mrMovingCamActive){
+			de.fruitfly.ovr.structs.Matrix4f temp2 = MCOpenVR.getAimRotation(2);
+			conrot = temp2.inverted().toFloatBuffer();
+		}else {
+			//reconstruct from vrsettings		
+			Matrix4f m = vrSettings.vrFixedCamrotQuat.getMatrix();
+
+			//m=m.rotate((float) Math.toRadians(-vrSettings.vrFixedCamrotYaw), new org.vivecraft.utils.lwjgl.Vector3f(0, 1, 0));
+			//m=m.rotate((float) Math.toRadians(-vrSettings.vrFixedCamrotPitch), new org.vivecraft.utils.lwjgl.Vector3f(1, 0, 0));
+			//m=m.rotate((float) Math.toRadians(vrSettings.vrFixedCamrotRoll), new org.vivecraft.utils.lwjgl.Vector3f(0, 0, 1));
+			// idk why this one was here
+			//m=m.rotate((float) Math.toRadians(180), new org.vivecraft.utils.lwjgl.Vector3f(0, 1, 0));
+			
+			matrixBuffer2.rewind();
+			m.store(matrixBuffer2);
+			matrixBuffer2.rewind();
+			conrot = matrixBuffer2;
+			
+		}
+
+		GlStateManager.matrixMode(GL11.GL_MODELVIEW);
+		GlStateManager.pushMatrix();
+			GlStateManager.loadIdentity();
+	
+			//Room pose
+			GlStateManager.translate(-roomo.x, -roomo.y, -roomo.z);
+			GlStateManager.rotate((float) Math.toDegrees(vrPlayer.vrdata_world_render.rotation_radians), 0, 1, 0);
+			//
+			//scale everything in the room
+			GlStateManager.scale(vrPlayer.vrdata_world_render.worldScale,
+					vrPlayer.vrdata_world_render.worldScale, 
+					vrPlayer.vrdata_world_render.worldScale);
+			///
+			
+			//Device Pose
+			Vec3d cp = vrPlayer.vrdata_room_pre.getController(2).getPosition();
+
+			GlStateManager.translate(-cp.x, -cp.y, -cp.z);
+							
+			//this is here because.
+			GlStateManager.multMatrix(conrot);
+	
+			//local offsets
+			GlStateManager.translate(-vrSettings.mrMovingCamOffsetX, -vrSettings.mrMovingCamOffsetY, -vrSettings.mrMovingCamOffsetZ);
+GlStateManager.multMatrix(Utils.convertToOVRMatrix(vrSettings.mrMovingCamOffsetRotQuat.getMatrix()).toFloatBuffer());
+			
+	
+	
+			//put back scale
+			GlStateManager.scale(1/vrPlayer.vrdata_world_render.worldScale, 1/vrPlayer.vrdata_world_render.worldScale, 1/vrPlayer.vrdata_world_render.worldScale);
+			//
+	
+			GlStateManager.getFloat(GL11.GL_MODELVIEW_MATRIX, matrixBuffer);
+		GlStateManager.popMatrix();
+
+		matrixBuffer.rewind();
+		this.thirdPassViewMatrix.load(matrixBuffer);
+		matrixBuffer.rewind();
+		return thirdPassViewMatrix;
+	}
+	
+	
+	public void printGLMatrix(String derp){
+		GlStateManager.getFloat(GL11.GL_MODELVIEW_MATRIX, matrixBuffer);
+		matrixBuffer.rewind();
+		Matrix4f temp = new Matrix4f();
+		temp.load(matrixBuffer);
+		System.out.println(derp + "\r\n" + temp.toString());
+		matrixBuffer.rewind();
+	}
+	
+	public void clearGLError() //bad bad bad
+	{
+		int var2 = GL11.glGetError();
+	}
+	//public org.lwjgl.util.vector.Matrix4f thirdPassInverseViewMatrix = new org.lwjgl.util.vector.Matrix4f();
+	public org.lwjgl.util.vector.Matrix4f thirdPassViewMatrix = new org.lwjgl.util.vector.Matrix4f();
+
+	private boolean copyToMirror(RenderPass currentPass2)
+	{
+		// VIVE start - render eye buffers to the desktop window
+
+		if(this.vrSettings.displayMirrorMode < vrSettings.MIRROR_OFF) //new values
+			this.vrSettings.displayMirrorMode = vrSettings.MIRROR_ON_DUAL;
+		
+		if(this.vrSettings.displayMirrorMode > vrSettings.MIRROR_MIXED_REALITY) //new values
+			this.vrSettings.displayMirrorMode = vrSettings.MIRROR_ON_DUAL;
+		
+		if (this.vrSettings.displayMirrorMode == vrSettings.MIRROR_OFF && MCOpenVR.isHMDTracking())
+		{
+			return false;
+		} 
+		else if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_MIXED_REALITY /*&& renderViewEntity != null*/) 
+		{			
+			if(currentPass2 != RenderPass.THIRD) return false;
+
+			if (VRShaders._DepthMask_shaderProgramId != 0) {
+				doMixedRealityMirror();
+			} else {
+				this.framebufferMc.unbindFramebuffer();	//draw directly to window
+				GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);
+				entityRenderer.displayNotificationText("Shader compile failed, see log", "", "", this.displayWidth, this.displayHeight, false, true);
+			}
+
+			return true;
+		} else { //left, right, undistorted, third.
+			int ports = 1;
+			Framebuffer source = stereoProvider.framebufferEye0;
+			int i = 0;
+
+			if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_FIRST_PERSON ) {
+				source = stereoProvider.framebufferUndistorted;
+			}else if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_THIRD_PERSON){
+				getMRTransform();
+				source = stereoProvider.framebufferMR;
+			} else if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_DUAL){
+				ports = 2;
+				if(currentPass2 == RenderPass.RIGHT) {
+					source = stereoProvider.framebufferEye1;
+					i=1;
+				}
+			} else if(this.vrSettings.displayMirrorMode == vrSettings.MIRROR_ON_SINGLE){
+				if(currentPass2 == RenderPass.LEFT)
+					return false;
+			}
+
+			this.framebufferMc.unbindFramebuffer();	//draw directly to window
+			source.framebufferRenderExt((displayWidth / 2) * i, displayWidth / ports, displayHeight, 0, true);
+			return true;
+			
+		}
+
+	}
+
+	private void doMixedRealityMirror() {
+		boolean hasShaders = Config.isShaders();
+		boolean alphaMask = this.vrSettings.mixedRealityUnityLike && this.vrSettings.mixedRealityAlphaMask;
+		
+		this.framebufferMc.unbindFramebuffer();	//draw directly to window
+					
+		//GL30.glBindFramebuffer(GL30.GL_DRAW_FRAMEBUFFER, 0);
+		//GL30.glBindFramebuffer(GL30.GL_READ_FRAMEBUFFER, stereoProvider.framebufferMR.framebufferObject);
+
+		if (!alphaMask) GlStateManager.clearColor(vrSettings.mixedRealityKeyColor.getRed() / 255F, vrSettings.mixedRealityKeyColor.getGreen() / 255F, vrSettings.mixedRealityKeyColor.getBlue() / 255F, 1);
+		else GlStateManager.clearColor(0, 0, 0, 1);
+		GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+
+		// create view matrix
+		
+		//temp
+//				vrSettings.mrMovingCamOffsetPitch = 0;
+//				vrSettings.mrMovingCamOffsetYaw = 0;
+//				vrSettings.mrMovingCamOffsetRoll = 0f;
+//				
+//				vrSettings.mrMovingCamOffsetX = 0f;
+//				vrSettings.mrMovingCamOffsetY = 0f;
+//				vrSettings.mrMovingCamOffsetZ = 0f;
+//				
+//				vrSettings.vrFixedCamrotYaw = 0;
+//				vrSettings.vrFixedCamrotRoll = 0;
+//				vrSettings.vrFixedCamrotPitch= 0;
+////				
+//				vrSettings.vrFixedCamposX = 0;
+//				vrSettings.vrFixedCamposY = 0;
+//				vrSettings.vrFixedCamposZ= 0;
+//				vrSettings.saveOptions();
+//				
+//				vrSettings.vrWorldRotation +=1f;
+//				vrPlayer.checkandUpdateRotateScale(true, 0);
+		//
+
+		getMRTransform();
+		
+		Vec3d derp = vrPlayer.vrdata_world_render.getController(2).getPosition();
+
+		Vec3d camplayer = new Vec3d(-thirdPassViewMatrix.m30, -thirdPassViewMatrix.m31, -thirdPassViewMatrix.m32).subtract(vrPlayer.vrdata_world_render.getEye(RenderPass.CENTER).getPosition());
+	//	Vec3d camplayer = derp.subtract(vrPlayer.vrdata_world_render.getEye(RenderPass.Center).getPosition());
+
+		camplayer = camplayer.rotateYaw((float) Math.PI);
+		
+		
+//	org.lwjgl.util.vector.Vector3f CameraLookx = new org.lwjgl.util.vector.Vector3f(0,0,-1); 
+//	org.lwjgl.util.vector.Vector3f CameraLooky = Utils.directionFromMatrix(thirdPassViewMatrix, 0, 0, -1);
+//	float yaw = (float) Math.toRadians(-vrSettings.vrFixedCamrotYaw - vrSettings.vrWorldRotation);
+//	float yawx = (float) Math.atan2((-thirdPassViewMatrix.m20),(Math.sqrt(Math.pow(thirdPassViewMatrix.m21, 2) + Math.pow(thirdPassViewMatrix.m22, 2))));
+		
+//	org.lwjgl.util.vector.Vector3f CameraLook = new org.lwjgl.util.vector.Vector3f((float) Math.sin(yaw), 0f, (float)Math.cos(yaw));
+
+		org.lwjgl.util.vector.Matrix4f viewMatrix = new org.lwjgl.util.vector.Matrix4f(thirdPassViewMatrix);
+		viewMatrix.m33 =1;
+		viewMatrix.m30 =0;
+		viewMatrix.m31 =0; 
+		viewMatrix.m32 =0;
+		
+		viewMatrix = (Matrix4f) viewMatrix.invert();
+		
+		org.lwjgl.util.vector.Vector3f CameraLook = Utils.directionFromMatrix(viewMatrix, 0, 0, 1);
+		
+		// Vec3d camplayerx = entityRenderer.getMRCamLocation().subtract(entityRenderer.getEyeRenderPos(RenderPass.Center));				
+
+		OpenGlHelper.glUseProgram(VRShaders._DepthMask_shaderProgramId);
+		
+		// set projection matrix
+		entityRenderer.thirdPassProjectionMatrix.store(matrixBuffer);
+		matrixBuffer.rewind();
+		ARBShaderObjects.glUniformMatrix4ARB(VRShaders._DepthMask_projectionMatrix, false, matrixBuffer);
+		
+		// set view matrix
+		viewMatrix.store(matrixBuffer);
+		matrixBuffer.rewind();
+		ARBShaderObjects.glUniformMatrix4ARB(VRShaders._DepthMask_viewMatrix, false, matrixBuffer);
+
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_colorTexUniform, 1);
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_depthTexUniform, 2);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdViewPosition, (float)camplayer.x, (float)camplayer.y, (float)camplayer.z);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_hmdPlaneNormal, (float)-CameraLook.x, 0, (float) CameraLook.z);
+		ARBShaderObjects.glUniform3fARB(VRShaders._DepthMask_keyColorUniform, vrSettings.mixedRealityKeyColor.getRed() / 255F, vrSettings.mixedRealityKeyColor.getGreen() / 255F, vrSettings.mixedRealityKeyColor.getBlue() / 255F);
+		ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_alphaModeUniform, alphaMask ? 1 : 0);
+
+		// bind color and depth textures
+		GlStateManager.setActiveTexture(GL13.GL_TEXTURE1);
+		stereoProvider.framebufferMR.bindFramebufferTexture();
+		GlStateManager.setActiveTexture(GL13.GL_TEXTURE2);
+		
+		if (hasShaders) 
+			GlStateManager.bindTexture(Shaders.dfbDepthTextures.get(0)); // shadersmod has it's own depth buffer
+		else 
+			GlStateManager.bindTexture(stereoProvider.framebufferMR.depthBuffer);
+		
+		GlStateManager.setActiveTexture(GL13.GL_TEXTURE0);
+
+		
+		for(int i = 0; i < (alphaMask ? 3 : 2); i++) {
+		
+			int resW = displayWidth / 2;
+			int resH = displayHeight;
+			int posW = (displayWidth / 2) * i;
+			int posH = 0;
+			
+			if (this.vrSettings.mixedRealityUnityLike) {
+				resW = displayWidth / 2;
+				resH = displayHeight / 2;
+				if (this.vrSettings.mixedRealityAlphaMask && i == 2) {
+					posW = displayWidth / 2;
+					posH = displayHeight / 2;
+				} else {
+					posW = 0;
+					posH = (displayHeight / 2) * (1 - i);
+				}
+			}
+			
+			// set other uniforms
+			ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_resolutionUniform, resW, resH);
+			ARBShaderObjects.glUniform2fARB(VRShaders._DepthMask_positionUniform, posW, posH);
+			ARBShaderObjects.glUniform1iARB(VRShaders._DepthMask_passUniform, i);
+
+			
+			// draw framebuffer
+			stereoProvider.framebufferMR.framebufferRenderExt(posW, resW, resH, posH, true);
+		}
+		
+		OpenGlHelper.glUseProgram(0);
+		
+		if (this.vrSettings.mixedRealityUnityLike) {
+			if(this.vrSettings.mixedRealityMRPlusUndistorted)
+				stereoProvider.framebufferUndistorted.framebufferRenderExt(displayWidth/ 2,displayWidth/ 2, displayHeight / 2, 0, true);
+			else
+				stereoProvider.framebufferEye0.framebufferRenderExt(displayWidth/ 2, displayWidth/ 2, displayHeight/ 2, 0, true);
+		}
+
+		
+	}
+
+	private float fov = 1.0f;
+	
+	public boolean reinitflag;
+
+	public GLConfig getLWJGLConfig(GLConfig glConfig)
+	{
+		// TODO: For LWJGL 3.0, this function may well be screwed...
+
+		// We need to retrieve certain pointers / handles from LWJGL
+		// for the Oculus SDK. However, these are not exposed by
+		// LWJGL, so use reflection to get hold of the data we need.
+
+		try
+		{
+			switch(LWJGLUtil.getPlatform())
+			{
+			case LWJGLUtil.PLATFORM_WINDOWS:
+			{
+				// Get HWND pointer...
+				if (fieldHwnd == null)
+				{
+					fieldHwnd = displayImpl.getClass().getDeclaredField("hwnd");
+					fieldHwnd.setAccessible(true);
+				}
+				glConfig.Window = (Long) fieldHwnd.get(displayImpl);
+				//System.out.println(String.format("[Minecrift] HWND: 0x%X", new Object[] {glConfig.Window}));
+				break;
+			}
+			case LWJGLUtil.PLATFORM_LINUX:
+			{
+				// Get Display and Window pointers...
+				if (fieldDisplay == null)
+				{
+					fieldDisplay = displayImpl.getClass().getDeclaredField("display");
+					fieldDisplay.setAccessible(true);
+				}
+				if (fieldWindow == null)
+				{
+					fieldWindow = displayImpl.getClass().getDeclaredField("current_window");
+					fieldWindow.setAccessible(true);
+				}
+				glConfig.Display = (Long) fieldDisplay.get(null);
+				glConfig.Window = (Long) fieldWindow.get(null);
+				//System.out.println(String.format("[Minecrift] Display: 0x%X", new Object[] {glConfig.Display}));
+				//System.out.println(String.format("[Minecrift] Window: 0x%X", new Object[] {glConfig.Window}));
+				break;
+			}
+			case LWJGLUtil.PLATFORM_MACOSX:
+			{
+				// Do nowt...
+				break;
+			}
+			default:
+				throw new Exception ("Current platform not supported!");
+			}
+		}
+		catch (Exception ex)
+		{
+			ex.printStackTrace();
+			glConfig = null;
+		}
+
+		return glConfig;
+	}
+	private int dispLastWidth, dispLastHeight;
+	public boolean wasDisplayResized()
+	{
+		int h = Display.getHeight();
+		int w = Display.getWidth();
+		
+		boolean was = dispLastHeight != h || dispLastWidth != w;
+		dispLastHeight = h;
+		dispLastWidth = w;
+		return was;
+	}
+
+	public void initMinecrift() throws Exception
+	{
+		
+	
+		this.lastGuiScale = this.gameSettings.guiScale;
+
+		// Get underlying LWJGL Display implementation
+		if (displayImpl == null)
+		{
+			try {
+				Method displayMethod = Display.class.getDeclaredMethod("getImplementation");
+				displayMethod.setAccessible(true);
+				displayImpl = displayMethod.invoke(null, (java.lang.Object[])null); // VIVE fix warning
+				System.out.println(String.format("[Minecrift] LWJGL Display implementation class: %s", new Object[]{displayImpl.getClass().toString()}));
+			}
+			catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+
+		try {
+			//Class.forName("org.vivecraft.provider.MCHydra").newInstance();//creates and registers MCHydra if it can be (if the libraries are found)
+			//hydraLibsAvailable = true;
+		} catch (NoClassDefFoundError e1) {
+			System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+		} catch( Exception e1) {
+			System.err.println("Skipping loading: [Razer Hydra library] (Sixense-Java): "+e1.toString());
+		}
+
+		new MCOpenVR();
+		MCOpenVR.init();
+		this.stereoProvider = new OpenVRStereoRenderer();
+		this.vrPlayer = new OpenVRPlayer();
+		this.vrSettings.vrAllowCrawling = false;
+		//hmdInfo = PluginManager.configureHMD("oculus");
+		
+		//register Trackers
+		vrPlayer.registerTracker(backpackTracker);
+		vrPlayer.registerTracker(bowTracker);
+		vrPlayer.registerTracker(climbTracker);
+		vrPlayer.registerTracker(autoFood);
+		vrPlayer.registerTracker(jumpTracker);
+		vrPlayer.registerTracker(rowTracker);
+		vrPlayer.registerTracker(runTracker);
+		vrPlayer.registerTracker(sneakTracker);
+		vrPlayer.registerTracker(swimTracker);
+		vrPlayer.registerTracker(swingTracker);
+		vrPlayer.registerTracker(teleportTracker);
+		vrPlayer.registerTracker(horseTracker);
+		vrPlayer.registerTracker(vehicleTracker);
+
+		//TODO: init new steroerenderer
+
+		nativeMouseCursor = Mouse.getNativeCursor();
+		try {
+			invisibleMouseCursor = new Cursor(1, 1, 0, 0, 1, BufferUtils.createIntBuffer(1), null);
+		} catch (LWJGLException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public void showNativeMouseCursor(boolean show)
+	{
+		if (show == lastShowMouseNative)
+			return;
+
+		lastShowMouseNative = show;
+
+		try
+		{
+			if (show)
+			{
+				Mouse.setNativeCursor(nativeMouseCursor);
+			}
+			else
+			{
+				Mouse.setNativeCursor(invisibleMouseCursor);
+			}
+		}
+		catch (LWJGLException e)
+		{
+			e.printStackTrace();
+		}
+	}
+
+	public double getCurrentTimeSecs()
+	{
+		return this.stereoProvider.getCurrentTimeSecs();
+	}
+
+boolean w;
+
+	public void drawQuad()
+	{
+		// this func just draws a perfectly normal box with some texture coordinates
+		GL11.glBegin(GL11.GL_QUADS);
+
+		// Front Face
+		GL11.glTexCoord2f(0.0f, 0.0f); GL11.glVertex3f(-1.0f, -1.0f,  0.0f);  // Bottom Left Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 0.0f); GL11.glVertex3f( 1.0f, -1.0f,  0.0f);  // Bottom Right Of The Texture and Quad
+		GL11.glTexCoord2f(1.0f, 1.0f); GL11.glVertex3f( 1.0f,  1.0f,  0.0f);  // Top Right Of The Texture and Quad
+		GL11.glTexCoord2f(0.0f, 1.0f); GL11.glVertex3f(-1.0f,  1.0f,  0.0f);  // Top Left Of The Texture and Quad
+
+		GL11.glEnd();
+	}
+
+	/**
+	 * Sets the listener of sounds
+	 */
+	public void updateSoundListener() {
+		boolean loaded  = (boolean) MCReflection.SoundManager_loaded.get(this.mcSoundHandler.sndManager);
+		if(loaded){
+			SoundSystem sndSystem = (SoundSystem) MCReflection.SoundManager_sndSystem.get(this.mcSoundHandler.sndManager);
+			Vec3d up = vrPlayer.vrdata_world_render.hmd.getCustomVector(new Vec3d(0, 1, 0));
+			Vec3d hmdPos = vrPlayer.vrdata_world_render.hmd.getPosition();
+			Vec3d hmdDir = vrPlayer.vrdata_world_render.hmd.getDirection();
+
+			if (sndSystem != null)
+			{
+				sndSystem.setListenerPosition((float)hmdPos.x, (float)hmdPos.y, (float)hmdPos.z);
+				sndSystem.setListenerOrientation((float)hmdDir.x, (float)hmdDir.y, (float)hmdDir.z, (float)up.x, (float)up.y, (float)up.z);
+			}
+		}
+	}
+
+	private static void sleepNanos (long nanoDelay)
+	{
+		final long end = System.nanoTime() + nanoDelay;
+		do
+		{
+			Thread.yield();  // This is a busy wait sadly...
+		}
+		while (System.nanoTime() < end);
+	}
+
+	private void addRunTickTimeNanos(long runTickTime)
+	{
+		int i = 0;
+		medianRunTickTimeNanos = runTickTime;
+
+		if (this.vrSettings.smoothRunTickCount < 1)
+			this.vrSettings.smoothRunTickCount = 1;
+
+		if (this.vrSettings.smoothRunTickCount % 2 == 0)
+		{
+			// Need an odd number for this
+			this.vrSettings.smoothRunTickCount++;
+		}
+
+		runTickTimeNanos.addFirst(runTickTime);
+		while (runTickTimeNanos.size() > this.vrSettings.smoothRunTickCount)
+			runTickTimeNanos.removeLast();
+
+		if (runTickTimeNanos.size() == this.vrSettings.smoothRunTickCount)
+		{
+			Long[] array = new Long[runTickTimeNanos.size()];
+			for (Iterator itr = runTickTimeNanos.iterator(); itr.hasNext(); i++)
+			{
+				array[i] = (Long)itr.next();
+			}
+			Arrays.sort(array);
+			medianRunTickTimeNanos = array[array.length / 2];
+		}
+	}
+
+	private long getMedianRunTickTimeNanos()
+	{
+		return medianRunTickTimeNanos;
+	}
+
+	public void triggerYawTransition(boolean isPositive) {
+	//	this.lookaimController.triggerYawTransition(isPositive);
+	}
+
+	public void print(String s)
+	{
+		s = s.replace("\n", "\n[Minecrift] ");
+		System.out.println("[Minecrift] " + s);
+	}
+	
+	public float watereffect, portaleffect, pumpkineffect;
+	private boolean renderSingleView(int eye, float nano) {
+		boolean shouldupdate = false;
+	
+				GlStateManager.clearColor(0f, 0, 0, 1f);	
+				GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
+				GlStateManager.enableTexture2D();	
+				GlStateManager.enableDepth();
+				
+						
+			this.mcProfiler.startSection("updateCameraAndRender");
+				if (!this.skipRenderWorld)
+				{
+					//Forge calls onRenderTickStart > move to ER.drawFrameBuffer
+	
+					///THIS IS WHERE EVERYTHING IS RENDERED
+						this.entityRenderer.updateCameraAndRender( nano, System.nanoTime());
+						
+					//Forge calls onRenderTickEnd > move to ER.drawFrameBuffer						
+				}
+			this.mcProfiler.endSection();
+			checkGLError("postucr " + eye);
+
+			if(currentPass == RenderPass.LEFT || currentPass == RenderPass.RIGHT) {	
+				//copies the rendered scene to eye tex with fsaa and other postprocessing effects.
+				this.mcProfiler.startSection("postprocesseye");
+
+				Framebuffer source = this.framebufferMc;
+
+				if (this.vrSettings.useFsaa)
+				{
+					this.mcProfiler.startSection("fsaa");
+					stereoProvider.doFSAA(Config.isShaders());
+					source = stereoProvider.fsaaLastPassResultFBO;
+					checkGLError("fsaa " + eye);
+					this.mcProfiler.endSection();
+				}
+
+				if(currentPass == RenderPass.LEFT)	
+					stereoProvider.framebufferEye0.bindFramebuffer(true); //draw to L eye tex
+				else
+					stereoProvider.framebufferEye1.bindFramebuffer(true); //draw to R eye tex
+
+				if(vrSettings.useFOVReduction && vrPlayer.getFreeMove()){
+					if( player !=null && (Math.abs(player.moveForward) > 0 || Math.abs(player.moveStrafing) > 0)) {	
+						fov -=0.05;
+						if(fov < 0.22) fov = 0.22f;
+					} else {
+						fov +=0.01;
+						if(fov > 0.8) fov = 0.8f;				
+					}
+				} else {
+					fov = 1f;
+				}
+				
+				ARBShaderObjects.glUseProgramObjectARB(VRShaders._FOVReduction_shaderProgramId);
+				ARBShaderObjects.glUniform1iARB(VRShaders._FOVReduction_TextureUniform, 0);
+		
+				if(pumpkineffect > 0){
+					ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, 0.25f);
+					ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.0f);
+				} else{
+					ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_RadiusUniform, fov);
+					ARBShaderObjects.glUniform1fARB(VRShaders._FOVReduction_BorderUniform, 0.06f);
+				}
+				
+				// VIVE start - screen flash when hurt instead of view tilt
+				float r = 0, k = 0;
+				// VIVE start - screen flash when hurt instead of view tilt
+				float time =  (float) (System.currentTimeMillis() - usageSnooper.getMinecraftStartTimeMillis()) / 1000;
+				if (player!=null && world !=null) {
+					
+					if(entityRenderer.wasinwater != entityRenderer.inwater) {
+						watereffect = 2.3f;				
+					} else {
+					if(entityRenderer.inwater){
+							watereffect -= (1f/120f);
+					} else {
+						watereffect -= (1f/60f);
+						}					
+						if(watereffect < 0) watereffect = 0;
+					}
+					
+					entityRenderer.wasinwater = entityRenderer.inwater;
+					
+					if(Config.isShaders()) watereffect = 0; //dont stack.
+					
+					if(entityRenderer.inportal){
+						portaleffect = 1f;
+					} else {
+						portaleffect -= (1f/60f);
+						if(portaleffect < 0) portaleffect = 0;
+					}
+					
+					float var3 = (float)player.hurtTime - nano;
+
+					float percent = 1 - player.getHealth() / player.getMaxHealth();
+					percent = (percent-0.5f) * 0.75f;
+
+					if (var3>0.0f)
+					{
+						var3 /= (float) player.maxHurtTime;
+						var3 = percent + MathHelper.sin(var3 * var3 * var3 * var3 * (float) Math.PI) * 0.5f;
+						r = var3;
+					} else {
+						r =  (float) (percent * Math.abs(Math.sin(2.5f*time/(1-percent+.1) )));
+						if (player.isCreative()) r = 0;
+					}
+					
+					if(entityRenderer.inblock && player.isDead == false){
+						//k = (float) entityRenderer.itemRenderer.inBlock;
+						
+					}
+				
+					if (player.isPlayerSleeping()){
+						if(k<0.8)k=.8f;
+					}
+					
+					if (MCOpenVR.isWalkingAbout){
+						if(k<0.8)k=.5f;
+					}
+						
+				} else {
+					watereffect = 0;
+					portaleffect = 0;
+				}
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_HealthAlpha, r);
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_BlackAlpha, k);
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_time,time);
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_waterAmplitude, watereffect);
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_portalAmplitutde, portaleffect);
+				ARBShaderObjects.glUniform1fARB(VRShaders._Overlay_pumpkinAmplitutde, pumpkineffect);		
+				ARBShaderObjects.glUniform1iARB(VRShaders._Overlay_eye, currentPass == currentPass.LEFT ? 1 : -1);		
+				
+				source.framebufferRender(stereoProvider.framebufferEye0.framebufferWidth, stereoProvider.framebufferEye0.framebufferHeight);
+
+				ARBShaderObjects.glUseProgramObjectARB(0);
+
+				checkGLError("post-draw " + eye);
+
+				this.mcProfiler.endSection();
+
+				//this.mcProfiler.startSection("OpenGL Finish");
+				//	GL11.glFinish();//DO NOT LEAVE THIS UNCOMMENTED
+				//this.mcProfiler.endSection();
+
+			}
+
+
+		this.mcProfiler.startSection("mirror");
+			shouldupdate = copyToMirror(this.currentPass);
+			checkGLError("post-mirror " + eye);
+		this.mcProfiler.endSection();
+
+		return shouldupdate;
+	}
+
+	public float getFrameDelta() {
+		return frameDelta;
+	}
+	
+	private float angleNormalize(float angle) {
+		angle %= 360;
+		if (angle < 0) angle += 360;
+		return angle;
+	}
+	
+	
+	private float angleDiff(float a, float b) {
+		float d = Math.abs(a - b) % 360;
+		float r = d > 180 ? 360 - d : d;
+		
+		int sign = (a - b >= 0 && a - b <= 180) || (a - b <=-180 && a- b>= -360) ? 1 : -1;
+		return r * sign;
+	
+	}
+	
+    public int getMouseXPos()
+    {
+     	if(Display.isCreated() && Display.isActive())
+    		return Mouse.getX() * currentScreen.width / this.displayWidth;
+    	else if (currentScreen != null)
+    		return (int) GuiHandler.controllerMouseX  * this.currentScreen.width / this.displayWidth;
+     	
+     	return 0;
+    }
+
+    public int getMouseYPos()
+    {
+    	if(Display.isCreated() && Display.isActive())
+    		return this.currentScreen.height - Mouse.getY() * this.currentScreen.height / this.displayHeight - 1;
+    	else if (currentScreen != null)
+    		return  (int) (this.currentScreen.height - GuiHandler.controllerMouseY * this.currentScreen.height / this.displayHeight - 1);
+    	
+    	return 0;
+    }
+    
+	// FORGE
+	public ItemColors getItemColors()
+	{
+		return this.itemColors;
+	}
+	
+    public SearchTreeManager getSearchTreeManager()
+    {
+    	return this.searchTreeManager;
+    }
+    //
+
 }
